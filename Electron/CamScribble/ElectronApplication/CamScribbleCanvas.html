<!DOCTYPE html>
<html>
<head>
  <style>
    #title-bar {
      width:100%;
      height:25px;
      background-color:#ff0000;
      -webkit-app-region: drag
    }
  </style>
  <title>CamScribbleOutput</title>
</head>
<body style='margin:0px;overflow:hidden;'>
  <div id='title-bar'></div>
  <canvas id='big-picture' style='width:100%;height:100%'></canvas>
</body>

<!-- Insert this line above script imports  -->
<script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
<script src="js/jquery.min.js"></script>
<script>if (window.module) module = window.module;</script>

<script>
const GlCanvasForDummies = require('./js/GlCanvasForDummies');
const CamScribble = require('cam_scribble').CamScribble;
const {ipcRenderer} = require('electron');

// Media recorder and array.
var recorder = null;
var recordChunk = [];

var recording = false;
var paused = false;

function isPaused() {
  return paused;
}

function stopRecording() {
  const { remote: { dialog } } = require('electron');

  if(recorder != null) {
    recorder.stop();

    const blob = new Blob(recordChunk);
    let fr = new FileReader();
    fr.onload = _ => {
        showSaveDialog(fr.result);
    }
    fr.readAsArrayBuffer(blob);

    function showSaveDialog(arrayBuffer) {
        let buffer = new Buffer(arrayBuffer);
        let dt = new Date();
        dialog.showSaveDialog({
            filters: [{
                name: `webm file`,
                extensions: ['webm']
            }]
        }, fileName => {
            if (fileName) {
                var fs = require('fs');
                fs.writeFile(fileName, buffer, function(err) {
                    if (err) {
                        alert("An error ocurred creating the file " + err.message);
                    }
                    recorder = null;
                });
            }
        });
    }
  }
}

function startRecording() {
  // In the renderer process.
  const {desktopCapturer} = require('electron');


  // Get the window stream.
  desktopCapturer.getSources({types: ['window', 'screen']}, (error, sources) => {
    if (error) throw error;


    for (let i = 0; i < sources.length; ++i) {
      if (sources[i].name === 'CamScribbleOutput') {

        navigator.webkitGetUserMedia({
          audio: false,
          video: {
            mandatory: {
              chromeMediaSource: 'desktop',
              chromeMediaSourceId: sources[i].id,
              minWidth: 1280,
              maxWidth: 1280,
              minHeight: 600,
              maxHeight: 600
            }
          }
        }, handleStream, handleError);

        return;
      }
    }



  });


  /*
  function getAudioChannel(videoSourceId) {

    MediaStreamTrack.getSources(function(sourceInfos) {

      for (var i = 0; i != sourceInfos.length; ++i) {
        //var sourceInfo = sourceInfos[i];
        if (sourceInfos[i].kind === 'audio') {
          sourceSelected(videoSourceId, sourceInfos[i].id);
          return
        }
      }

      //sourceSelected(audioSource, videoSource);
    });
  }

  function sourceSelected(videoSourceId,audioSourceId) {
    navigator.webkitGetUserMedia({
      audio: {
        optional: [{sourceId: audioSourceId}]
      },
      video: {
        optional: [{sourceId: videoSourceId}]
      }
    }, handleStream, handleError);
  }

  */

  function handleStream (stream) {
    //document.querySelector('video').src = URL.createObjectURL(stream)
    recorder = new MediaRecorder(stream);

    // tell it to save data to an object when available
    recorder.ondataavailable = e => {
      recordChunk.push(e.data);
    };

    recorder.start();

  }

  function handleError (e) {
    console.log(e)
  }
}



function toggleRecording() {
  if(recording) {
    stopRecording();
  } else {
    paused = false;
    startRecording();
  }

  recording = recording != true;
}


function togglePause() {
  if(recorder != null) {
    if(paused) {
      recorder.resume();
      paused = false;
    } else {
      recorder.pause();
      paused = true;
    }
  }
}

function setupMouseDragOnCanvas(camScribble) {
  var canvas = document.getElementById('big-picture');
  var rect = canvas.getBoundingClientRect();
  var flag = false;
  var position = [0.5,0.5];

  function handleMouseEvent(type,event) {
    switch(type) {
      case 'mouseup':
      case 'mouseout':
        flag = false;
        break;
      case 'mousedown':
        flag = true;
        position[0] = (event.clientX - rect.left)/(rect.width);
        position[1] = (event.clientY - rect.top)/(rect.height);

        break;
      case 'mousemove':
        if(flag) {
          position[0] = (event.clientX - rect.left)/(rect.width);
          position[1] = (event.clientY - rect.top)/(rect.height);
        }

        break;
    }

    if(flag) {
      camScribble.setPosition(position[0],position[1]);

    }
  }

  canvas.addEventListener("mousemove", function (e) {
      handleMouseEvent('mousemove', e)
  }, false);
  canvas.addEventListener("mousedown", function (e) {
      handleMouseEvent('mousedown', e)
  }, false);
  canvas.addEventListener("mouseup", function (e) {
      handleMouseEvent('mouseup', e)
  }, false);
  canvas.addEventListener("mouseout", function (e) {
      handleMouseEvent('mouseout', e)
  }, false);

}

function showErrorDialogAndExit(message) {
  const {dialog} = require('electron').remote;
  const {remote} = require('electron').remote;

  dialog.showMessageBox({
    type:'error',
    buttons:['Ok'],
    message: message,
    cancelId: -1
  });

  ipcRenderer.send('application-control-message','exit');
}

function setupIPCControls(camScribble) {
  ipcRenderer.on('cs-controls',function(event, data) {
    switch(data.action) {
      case 'undo':
        camScribble.undo();
        break;
      case 'redo':
        camScribble.redo();
        break;
      case 'erase':
        break;
      case 'lock':
        camScribble.lock();
        break;
      case 'clear':
        camScribble.clearBigCanvas();
        break;
      case 'export':
        break;
      case 'noise':
        camScribble.setNoise(data.val);
        break;
      case 'stroke':
        camScribble.setStrokeWidth(data.val);
        break;
      case 'brightness':
        camScribble.setBrightness(data.val);
        break;
      case 'width':
        camScribble.setWidth(data.val);
        break;
      case 'height':
        camScribble.setHeight(data.val);
        break;
      case 'color':
        //ipcRenderer.send('debugging-logs',data.val);
        camScribble.setInkColor(parseInt(data.val.r),parseInt(data.val.g),parseInt(data.val.b))
        break;
      case 'toggle-record':
        toggleRecording();
        break;
      case 'toggle-pause':
        togglePause();
        break;
    }
  });
}

function init(camScribble) {
  var fs = require('fs');
  fs.readFile('calibration.config','utf-8',function(err,data) {

    if(err) {
      showErrorDialogAndExit('Unable to read configuration file');
    }


    var configuration = JSON.parse(data);
    var perspectivePoints = configuration.perspectiveCorrection;



    camScribble.setPerspective(perspectivePoints);
    var cameras = camScribble.getAvailableCameras();
    if(cameras.length == 0) {
      showErrorDialogAndExit('No camera found!');
    }


    var cameraFound = false;
    for(var i=0;i<cameras.length;i++) {
      if(cameras[i] == parseInt(configuration.camera)) {
        cameraFound = true;
      }
    }

    if(!cameraFound) {
      showErrorDialogAndExit('Camera not found! Consider re-calibrating.');
    }

    camScribble.setCamera(parseInt(configuration.camera));
    selectedCamera = parseInt(configuration.camera);


    var buffer = null;
    camScribble.getBigCanvas(function(image) {
      var buf = image.toBuffer();

      var glCan = new GlCanvasForDummies(
        document.getElementById('big-picture'),
        image.width(),
        image.height());

      document.getElementById('big-picture')
        .setAttribute("style","width:"+image.width()+"px;height:"+image.height()+"px");

      // Setup mouse movement calback after
      // the canvas has been resized.
      setupMouseDragOnCanvas(camScribble);

      function renderLoop() {
        camScribble.getBigCanvas(function(image) {
          buf = image.toBuffer(buf);
          glCan.renderImage(buf,image.width(),image.height());

          setTimeout(
            function() {
              requestAnimationFrame(renderLoop)
          },1000/30);
        });
      }
      // Enter the rendering
      renderLoop();


    });


    setupIPCControls(camScribble);



  });
}

$(document).ready(function() {

  var camScribble = new CamScribble([600,600],[0,0,0]);

  init(camScribble);
});

</script>
</html>
